Сервис для проверки доступности интернет-ресурсов с генерацией PDF отчетов.
_____________

Архитектура

Проект следует принципам чистой архитектуры с разделением на слои:
- cmd/main.go: здесь стартует приложение
- internal:
     - config: конфиги
     - domain: модели бизнес логики
     - handler: серверные обработчики API
     - pdf: логика сборки PDF отчётов
     - repository: всё для работы с хранилищем
     - service: бизнес-логика сервиса, в которую проваливаются обработчики

Какие паттерны использовались:
1. Паттер "Репозиторий"
Бизнес логика (service) работает с хранилищем через интерфейс. Сейчас этот интерфейс реализован через sqlite, потому что по условию задачи нужно без инфраструктурной БД обойтись. Но при эволюции сервиса можно будет добавить новое внешнее хранилище, чтобы несколько подов этого сервиса имели единое хранилище.

2. Паттерн "Инъекция зависимостей"
Зависимости передаются через конструкторы, что упрощает тестирование и замену компонентов.

3. Паттерн "Ограничение количества параллельных задач через семафор"
Для ограничения количества одновременных проверок используется семафор на основе буферизованного канала.

4. Graceful Shutdown
Сервер корректно завершает работу при получении сигналов SIGINT/SIGTERM: останавливает прием новых запросов и ждёт, когда завершатся текущие запросы с таймаутом. Честно, через чтение сигналов операционки ещё никогда ничего не делала, но гуглёж показал такой вариант, надеюсь это то, что ожидалось, по крайней мере проверяла через sleep, что корректно успевают дообработаться задачи.


__________________

Нюансы реализации, на которые можно обратить внимание.

1. При создании нового набора ссылок система проверяет, существует ли уже такой набор в базе и если существует, то возвращает ID уже имеющегося набора. Если появится авторизация пользователей и у каждого пользователя должен быть свой набор задач, которые могут совпадать, то придётся дорабатывать это место и добавлять привязку задачи к пользователю.

2. По условиям задачи сказано не использовать внешнюю инфраструктуру, поэтому в качестве базы данных здесь используется локальное хранилище на базе sqllite. 
Хранение построено на двух таблицах:
- link_check_tasks: таблица зарегистрированных задач
- link_statuses: таблица статусов доступности предоставленных в задачах ссылок

Зачем выделила отдельную таблицу под статусы обработки - чтобы можно было параллельно обновлять статусы отдельных ссылок и получать историю проверок (по дате создания).

3. Ссылки проверяются параллельно с ограничением на количество горутин через семафор.
Это сделано, чтобы ускорить обработку, но при этом для больших задач не устраивать лавинообразный рост горутин и соответственно нагрузку на сеть.

4. В теории я понимаю, что тут можно использовать inbox паттерн, если бы сервис был высоконагруженным: получаем сообщение, сохраняем его в базу и робот-писатель регулярно выгружает те задачи, которые не в работе в поток данных (канал, кафка, grpc стрим или ещё что-то), который уже разгребается обработчиком (сервис, горутина), который после обработки задачи отправляет результаты в другой поток данных, который уже разгребается роботом-читателем, который сохраняет результаты обработки задач и шлёт уведомления дальше.

_______________
API

1. POST /api/check
Проверка доступности ссылок.
Запрос: {"links": ["google.com", "malformedlink.gg"]}
Ответ: {"links": {"google.com": "available", "malformedlink.gg": "not available"}, "links_num": 1}

2. GET /api/report
Генерация PDF отчета для списка задач. До этого мне не приходилось иметь дела с генерацией PDF из go, что удалось быстро нагуглить, то и применила, поэтому отчёт получился очень простой.

Запрос: {"links_list": [1, 2]}
Ответ: PDF файл с результатами проверок.

3. GET /health
Проверка работоспособности сервера. Не стала убирать, потому что периодически помогает при отладке системы.


Для реального сервиса контракты писала бы через proto и через автогенерацию генерировала бы как модельки, так и сервер/клиент, так и openapi. Но для этой задачи это будет избыточно.

_______________

Запуск, настройки и тестирование.

Запуск:
- go run cmd/main.go
- или через компиляцию и запуск: "go build -o bin/server cmd/main.go && ./bin/server"


Конфигурация поддерживает переменные окружения:
- SERVER_PORT: порт сервера (по умолчанию: 8080)
- DB_PATH: путь к файлу БД (по умолчанию: links.db)

Энвы добавила просто по примеру с боевыми проектами, но считаю что они тут нужны, потому что если даже такой простой сервис будет запускаться на разных машинах, то как минимум порт сервера точно потребуется менять.

Тесты:
Юнит тесты тут не писала, потому что обычно пишу их с помощью ИИшки, потому что так быстрее и качественнее (зачастую), но тут сказано не пользоваться, поэтому не стала рисковать, но уже не успеваю написать тесты руками.


Тестировала руками через postman:
Коллекцию для быстрого использования прикреплена в репозиторий как postman_collection.json.
Достаточно импортировать в свой постман и будет доступно три API: постановка задачи, генерация отчёта и лайфчек.